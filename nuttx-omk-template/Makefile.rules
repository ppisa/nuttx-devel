#  Makefile.rules - OCERA make framework common project rules -*- makefile-gmake -*- #OMK:base.omk
#
#  (C) Copyright 2003, 2006, 2007, 2008, 2009  by Pavel Pisa - OCERA team member
#  (C) Copyright 2009, 2010, 2011, 2013, 2015, 2016, 2017, 2019 by Pavel Pisa - PiKRON.com
#  (C) Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2013, 2015 by Michal Sojka - Czech Technical University, FEE, DCE
#
#  Homepage: http://rtime.felk.cvut.cz/omk/
#  Version:  0.2-206-g2e73801
#
# The OMK build system is distributed under the GNU General Public
# License.  See file COPYING for details.
#
#
#                   Version for system-less builds.                              #OMK:sysless.omk
#
#
# input variables                                                                #OMK:base.omk
# V                .. if set to 1, full command text is shown else short form is used
# W                .. whole tree - if set to 1, make is always called from the top-level directory
# SUBDIRS          .. list of subdirectories intended for make from actual directory
# default_CONFIG   .. list of default config assignments CONFIG_XXX=y/n ...
# LN_HEADERS       .. if "y", header files are symbolicaly linked instead of copied. #OMK:include.omk
# bin_PROGRAMS     .. list of the require binary programs                        #OMK:sysless.omk
# test_PROGRAMS    .. list of the test programs
# include_HEADERS  .. list of the user-space public header files
# lib_LIBRARIES    .. list of the user-space libraries
# lib_LDSCRIPTS    .. list of LD scripts that should be copied to the lib direcotry
# lib_obj_SOURCES  .. list of source files which should be compiled and
#		      the produced object file placed to the lib directory (e.g. crt0.S)
# shared_LIBRARIES .. list of the user-space shared libraries
# nobase_include_HEADERS .. public headers copied even with directory part
# renamed_include_HEADERS .. public headers copied to the different target name (xxx.h->yyy.h)
# utils_PROGRAMS   .. list of the development utility programs (compiled for host computer, this might change in future)
# xxx_SOURCES      .. list of specific target sources
# xxx_LIBS         .. list of specific target libraries
# INCLUDES         .. additional include directories and defines for user-space
# lib_LOADLIBES    .. list of libraries linked to each executable
# link_VARIANTS    .. list of ld script suffixes (after hypen `-') that
#                     should be used for linking (e.g. ram flash). If this is not
#		      specified, then the value of DEFAULT_LD_SCRIPT_VARIANT from config.target is used.
# PREFIX_DIR       .. Prefix to  directories in _compiled and _build. Used in config.omk.
# TARGET_STDSTARTFILES .. if left unset or set to `n', startup file provided
#                     by compiler is supressed
# cmetric_include_HEADERS    .. generate header file with offsets and sizes of structure fields #OMK:cmetric.omk
# xxx_CMETRIC_SOURCES	     .. the source cmetric generation
# LOCAL_CONFIG_H   .. name of local config.h file generated from values          #OMK:config_h.omk
#                     of options defined in the current directory
# config_include_HEADERS .. names of global config files (possibly
#                     with subdirectories)
# xxx_DEFINES      .. list of config directives to be included in
#                     config header file of the name <somedir>/xxx.h
# DOXYGEN          .. if non-empty, generated headers includes Doxygen's @file
# 		      command, so it is possible to document config
# 		      variables.
# local_EVALUATE   .. Makefile hook, which is executed at the end of             #OMK:localeval.omk
#                     the Makefile.rules. Used only for dirty hacks.
OMK_RULES_TYPE=nuttx                                                             #OMK:Makefile.rules.nuttx@
                                                                                 #OMK:base.omk@Makefile.rules.nuttx
# If we are not called by OMK leaf Makefile...
ifndef MAKERULES_DIR
MAKERULES_DIR := $(abspath $(dir $(filter %Makefile.rules,$(MAKEFILE_LIST))))
endif

# The $(SED4OMK) command for BSD based systems requires -E option to allow
# extended regular expressions

SED4OMK ?= sed
ifneq ($(shell ( echo A | $(SED4OMK) -n -e 's/A\|B/y/p' )),y)
  SED4OMK := $(SED4OMK) -E
  ifneq ($(shell ( echo A | $(SED4OMK) -n -e 's/A\|B/y/p' )),y)
    SED4OMK := gsed
  endif
  ifneq ($(shell ( echo A | $(SED4OMK) -n -e 's/A\|B/y/p' )),y)
    SED4OMK := gsed -E
  endif
  ifneq ($(shell ( echo A | $(SED4OMK) -n -e 's/A\|B/y/p' )),y)
    $(error No SED program suitable for OMK found)
  endif
endif

# OUTPUT_DIR is the place where _compiled, _build and possible other
# files/directories are created. By default is the same as
# $(MAKERULES_DIR).
ifndef OUTPUT_DIR
OUTPUT_DIR := $(MAKERULES_DIR)
endif

# We need to ensure definition of sources directory first
ifndef SOURCES_DIR
# Only shell built-in pwd understands -L
SOURCES_DIR := $(shell ( pwd -L ) )
INVOCATION_DIR := $(SOURCES_DIR:$(OUTPUT_DIR)%=%)
INVOCATION_DIR := $(INVOCATION_DIR:/%=%)
INVOCATION_DIR := $(INVOCATION_DIR:\\%=%)
endif

.PHONY: all default check-make-ver print-hints omkize

ifdef W
  ifeq ("$(origin W)", "command line")
    OMK_WHOLE_TREE:=$(W)
  endif
endif
ifndef OMK_WHOLE_TREE
  OMK_WHOLE_TREE:=0
endif

ifneq ($(OMK_WHOLE_TREE),1)
all: check-make-ver print-hints default
	@echo "Compilation finished"
else
# Run make in the top-level directory
all:
	@$(MAKE) -C $(MAKERULES_DIR) OMK_SERIALIZE_INCLUDED=n SOURCES_DIR=$(MAKERULES_DIR) RELATIVE_DIR="" $(MAKECMDGOALS) W=0
endif

# omk-get-var target allows external scripts/programs to determine the
# values of OMK variables such as RELATIVE_DIR etc.
.PHONY: omk-get-var
omk-get-var:
	@$(foreach var,$(VAR),echo $(var)=$($(var));)

#=========================
# Include the config file

ifndef CONFIG_FILE
CONFIG_FILE      := $(OUTPUT_DIR)/config.omk
endif

$(CONFIG_FILE)-default:
	$(MAKE) default-config 

ifeq ($(MAKECMDGOALS),default-config)
export DEFAULT_CONFIG_PASS=1
endif

ifneq ($(DEFAULT_CONFIG_PASS),1)
include $(CONFIG_FILE)-default
endif

-include $(OUTPUT_DIR)/config.target

ifneq ($(wildcard $(CONFIG_FILE)),)
-include $(CONFIG_FILE)
endif


CONFIG_FILES ?= $(wildcard $(CONFIG_FILE)-default) $(wildcard $(OUTPUT_DIR)/config.target) $(wildcard $(CONFIG_FILE))


export SED4OMK SOURCES_DIR MAKERULES_DIR RELATIVE_DIR INVOCATION_DIR
export CONFIG_FILE CONFIG_FILES OMK_SERIALIZE_INCLUDED OMK_VERBOSE OMK_SILENT
# OMK_SERIALIZE_INCLUDED has to be exported to submakes because passes
# must to be serialized only in the toplevel make.

ifndef RELATIVE_DIR
RELATIVE_DIR := $(SOURCES_DIR:$(OUTPUT_DIR)%=%)
endif
#$(warning  === RELATIVE_DIR = "$(RELATIVE_DIR)" ===)
override RELATIVE_DIR := $(RELATIVE_DIR:/%=%)
override RELATIVE_DIR := $(RELATIVE_DIR:\\%=%)
#$(warning  RELATIVE_DIR = "$(RELATIVE_DIR)")
#override BACK2TOP_DIR := $(shell echo $(RELATIVE_DIR)/ | $(SED4OMK) -e 's_//_/_g' -e 's_/\./_/_g' -e 's_^\./__g'  -e 's_\([^/][^/]*\)_.._g' -e 's_/$$__')
#$(warning  BACK2TOP_DIR = "$(BACK2TOP_DIR)")

#$(warning SOURCES_DIR = "$(SOURCES_DIR)")
#$(warning MAKERULES_DIR = "$(OUTPUT_DIR)")
#$(warning RELATIVE_DIR = "$(RELATIVE_DIR)")

# We have to use RELATIVE_PREFIX because of mingw
override RELATIVE_PREFIX := $(RELATIVE_DIR)/
override RELATIVE_PREFIX := $(RELATIVE_PREFIX:/%=%)

#vpath %.c $(SOURCES_DIR)
#vpath %.cc $(SOURCES_DIR)
#vpath %.cxx $(SOURCES_DIR)

# Define srcdir for Automake compatibility
srcdir = $(SOURCES_DIR)

# Defines for quiet compilation
ifdef V
  ifeq ("$(origin V)", "command line")
    OMK_VERBOSE = $(V)
  endif
endif
ifndef OMK_VERBOSE
  OMK_VERBOSE = 0
endif
ifneq ($(OMK_VERBOSE),0)
  Q =
else
  Q = @
endif
ifneq ($(findstring s,$(MAKEFLAGS)),)
  QUIET_CMD_ECHO = true
  OMK_SILENT = 1
else
  QUIET_CMD_ECHO = echo
endif

MAKEFILE_OMK=Makefile.omk
# All subdirectories (even linked ones) containing Makefile.omk
# Usage in Makefile.omk: SUBDIRS = $(ALL_OMK_SUBDIRS)
ALL_OMK_SUBDIRS = $(patsubst %/$(MAKEFILE_OMK),%,$(patsubst $(SOURCES_DIR)/%,%,$(wildcard $(SOURCES_DIR)/*/$(MAKEFILE_OMK))))

# ===================================================================
# We have set up all important variables, so we can check and include
# real OCERA style Makefile.omk now
ifndef OMK_INCLUDED
include $(SOURCES_DIR)/$(MAKEFILE_OMK)
ifeq ($(AUTOMATIC_SUBDIRS),y)
SUBDIRS?=$(ALL_OMK_SUBDIRS)
endif
OMK_INCLUDED := 1
endif

print-hints:
	@echo 'Use "make V=1" to see the verbose compile lines.'

check-make-ver:
	@GOOD_MAKE_VERSION=`echo $(MAKE_VERSION) | $(SED4OMK) -n -e 's/^[4-9]\..*\|^3\.9[0-9].*\|^3\.8[1-9].*/y/p'` ; \
	if [ x$$GOOD_MAKE_VERSION != xy ] ; then \
		echo "Your make program version ($(MAKE_VERSION)) is too old and does not support OMK system." ; \
		echo "Please update to make program 3.81beta1 or newer." ; exit 1 ; \
	fi

distclean dist-clean:
	@$(QUIET_CMD_ECHO) "  RM      $(COMPILED_DIR_NAME) $(BUILD_DIR_NAME)"
	@rm -fr $(OUTPUT_DIR)/$(COMPILED_DIR_NAME)  $(OUTPUT_DIR)/$(BUILD_DIR_NAME)

# Common OMK templates
# ====================

# Syntax: $(call mkdir,<dir name>)
define mkdir_def
	[ -d $(1) ] || mkdir -p $(1) || exit 1
endef

ifneq ($(OMK_VERBOSE),2)
NO_PRINT_DIRECTORY := --no-print-directory
endif

ifeq ($(USE_LEAF_MAKEFILES),n)
export USE_LEAF_MAKEFILES
SUBDIR_MAKEFILE=$(MAKERULES_DIR)/Makefile.rules
SOURCESDIR_MAKEFILE=$(MAKERULES_DIR)/Makefile.rules
else
SUBDIR_MAKEFILE=$(SOURCES_DIR)/$(3)/Makefile
SOURCESDIR_MAKEFILE=$(SOURCES_DIR)/Makefile
endif

pass = $(strip $(1))

unexport SUBDIRS

# Call a pass in a subdirectory
# Usage: $(call omk_pass_subdir_template,<pass name>,<build dir>,<subdir>)
define omk_pass_subdir_template
.PHONY: $(pass)-$(3)-subdir
$(pass)-submakes: $(pass)-$(3)-subdir
$(pass)-$(3)-subdir: MAKEOVERRIDES:=$(filter-out SUBDIRS=%,$(MAKEOVERRIDES))
$(pass)-$(3)-subdir:
	@$(call mkdir_def,$(2)/$(3))
	+@$(MAKE) --no-builtin-rules SOURCES_DIR=$(SOURCES_DIR)/$(3) $(NO_PRINT_DIRECTORY) \
		RELATIVE_DIR=$(RELATIVE_PREFIX)$(3) -C $(2)/$(3) \
		-f $(SUBDIR_MAKEFILE) $(pass)-submakes
# In subdirectories we can call submakes directly since passes are
# already serialized on the toplevel make.
endef

ifdef OMK_TESTSROOT
check-target = $(1:%=%-check)
endif

# Call a pass in a subdirectory
# Usage: $(call extra_rules_subdir_template,<subdir>)
define extra_rules_subdir_template
extra-rules-subdirs: extra-rules-$(1)
extra-rules-$(1):
	+@$(MAKE) OMK_SERIALIZE_INCLUDED=n MAKERULES_DIR=$(SOURCES_DIR)/$(1) OUTPUT_DIR=$(OUTPUT_DIR) \
		SOURCES_DIR=$(SOURCES_DIR)/$(1) RELATIVE_DIR=$(RELATIVE_PREFIX)$(1) -C $(SOURCES_DIR)/$(1)
endef

.PHONY: extra-rules-subdirs
extra-rules-subdirs:

$(foreach subdir,$(EXTRA_RULES_SUBDIRS),$(eval $(call extra_rules_subdir_template,$(subdir))))

# Usage: $(call omk_pass_template,<pass name>,<build dir>,[<local make flags>],[<local enable condition>])
define omk_pass_template
.PHONY: $(pass) $(pass)-local $(pass)-check $(pass)-submakes
$(foreach subdir,$(SUBDIRS),$(eval $(call omk_pass_subdir_template,$(pass),$(2),$(subdir))))
$(pass):
# Submakes have to be called this way and not as dependecies for pass
# serialization to work
	+@$(MAKE) --no-builtin-rules SOURCES_DIR=$(SOURCES_DIR) $(NO_PRINT_DIRECTORY) \
		RELATIVE_DIR=$(RELATIVE_DIR) \
		-f $(SOURCESDIR_MAKEFILE) $(pass)-submakes
$(pass)-submakes:
	@true			# Do not emit "nothing to be done" messages

ifneq ($(4)$($(pass)_HOOKS)$($(pass)_REQUIRED),)
$(pass)-submakes: $(pass)-this-dir
$(pass)-this-dir: $(foreach subdir,$(SUBDIRS),$(pass)-$(subdir)-subdir)
	+@echo "make[omk]: $(pass) in $(RELATIVE_DIR)"
	@$(call mkdir_def,$(2))
	+@$(MAKE) --no-builtin-rules $(NO_PRINT_DIRECTORY) SOURCES_DIR=$(SOURCES_DIR) RELATIVE_DIR=$(RELATIVE_DIR) -C $(2) \
	        -f $(SOURCESDIR_MAKEFILE) $(3) $(check-target) $(1:%=%-local)
ifneq ($(pass),clean)
$(pass)-local: $($(pass)_HOOKS)
endif
endif
endef

# =======================
# DEFAULT CONFIG PASS

default-config:
	@echo "# Start of OMK config file" > "$(CONFIG_FILE)-default"
	@echo "# This file should not be altered manually" >> "$(CONFIG_FILE)-default"
	@echo "# Overrides should be stored in file $(notdir $(CONFIG_FILE))" >> "$(CONFIG_FILE)-default"
	@echo >> "$(CONFIG_FILE)-default"
	@$(MAKE) $(NO_PRINT_DIRECTORY) -C $(OUTPUT_DIR) \
		RELATIVE_DIR="" SOURCES_DIR=$(OUTPUT_DIR) \
		-f $(OUTPUT_DIR)/Makefile default-config-pass

$(eval $(call omk_pass_template,default-config-pass,$$(LOCAL_BUILD_DIR),,always))

default-config-pass-local:
#	@echo Default config for $(RELATIVE_DIR)
	@echo "# Config for $(RELATIVE_DIR)" >> "$(CONFIG_FILE)-default"
	@$(foreach x, $(default_CONFIG), echo '$(x)' | \
		$(SED4OMK) -e 's/^[^=]*=x$$/#\0/' >> "$(CONFIG_FILE)-default" ; )


omkize:
	$(Q)if ! grep -q MAKERULES_DIR Makefile; then \
	   echo "Makefile is not OMK leaf makefile!" >&2; exit 1; \
	fi
	$(Q)for i in `find -L . -name Makefile.omk` ; do \
	   d=`dirname $${i}`; \
	   if ! test -f "$${d}/Makefile.rules" && ! cmp -s Makefile "$${d}/Makefile"; then \
	      rm -f "$${d}/Makefile"; \
	      cp -v Makefile "$${d}/Makefile"; \
	   fi \
	done
                                                                                 #OMK:nuttx-compile.omk@Makefile.rules.nuttx
# Rules for NuttX binaries compilation of C, C++ and assembler
# sources using GNU toolchain.

# Interface to other rules:
# kernel_HEADERS   .. list of the kernel-space public header files
# kernel_MODULES   .. list of the kernel side modules/applications

# Input variables:
# NUTTX_EXPORT - export directory of NuttX build
#                it should contain subdirectories:
#                arch  build  include  libs  registry  startup)
# LIB_DIR - directory where compiled libraries are stored
# OBJS_DIR - directory where intermediate files (.o, .map, ...) are stored
# INCLUDE_DIR - where includes can be found
# from config.omk or Makefile.omk
# CROSS_COMPILE - target architecture tools prefix
# TARGET_ARCH, DEBUG, OPTIMIZE, DEFS - forms CFLAGS
# from base: SOURCES_DIR
# from Makefile.omk: lib_LOADLIBES
# xxx_PROGBUILTIN - list of builtin programs linked into final system image
#                   when "all" is used then all programs provided by build are linked
# xxx_PROGBUILTIN_EXCLUDE - list of builtin user or NuttX provided programs which are excluded
# xxx_KMODBUILTIN - list of builtin programs linked into final system image

# Output variables:
# SOURCES - all the source files that needs to be compiled (except for shared library sources)
# SOLIB_SOURCES - all the source files that needs to be compiled for a shared library
# OBJ_EXT - extension of object files
# LIB_EXT - extension of library files
# LIB_PREF - prefix for library files
# ASM_EXT - extension of assembler sources

# Templates:
# COMPILER_DEFS_template - definitions that should be defined before
# the following templates can be used. The input variables needs to be
# defined before evaluating this template

# COMPILE_c_o_template, COMPILE_cc_o_template, COMPILE_S_o_template -
# templates that create rules for compilation of sources

# PROGRAM_template, LIBRARY_template, SOLIB_template - templates that
# create rules for compilation of a program, library and shared
# library. The rules can use rules produced by COMPILE_xxx_template.

EMPTY :=
LD_OPTION_SEP = $(EMPTY) $(EMPTY)

define COMPILER_DEFS_template
OBJ_EXT ?= $$(OBJEXT)
ifeq ($$(OBJ_EXT),)
OBJ_EXT = .o
endif
LIB_EXT ?= $$(LIBEXT)
ifeq ($$(LIB_EXT),)
LIB_EXT = .a
endif

LIB_PREF = lib
ASM_EXT = .S

CROSS_COMPILE ?= $$(CROSSDEV)

CC ?= $$(CROSS_COMPILE)gcc
CXX ?= $$(CROSS_COMPILE)g++
LD ?= $$(CROSS_COMPILE)ld
ifneq ($$(filter -Wl%, $$(NXFLATLDFLAGS1)$$(NXFLATLDFLAGS2)$$(LDFLAGS)),)
CC_LD_OPTION = -Wl,
LD_OPTION_SEP := ,
LD_BY_CC := 1
LD_RAW ?= $$(CROSS_COMPILE)ld
endif
LD_RAW ?= $$(LD)
AR ?= $$(CROSS_COMPILE)ar
OBJCOPY ?= $$(CROSS_COMPILE)objcopy
NM ?= $$(CROSS_COMPILE)nm

ifeq ($$(LDSTARTGROUP),)
LDSTARTGROUP = $$(CC_LD_OPTION)--start-group
LDENDGROUP = $$(CC_LD_OPTION)--end-group
endif

NUTTXLIBES += $$(LDSTARTGROUP) $$(LDLIBS) $$(EXTRA_LIBS) $$(LDENDGROUP)
NUTTXREGISTRY += $$(NUTTX_EXPORT)/registry

TARGET_ARCH += $$(ARCHCFLAGS) $$(ARCHCPUFLAGS)

OPTIMIZE ?= $$(ARCHOPTIMIZATION)

CFLAGS += $$(ARCHWARNINGS)
CXXFLAGS += $$(ARCHCXXFLAGS)
CXXFLAGS += $$(ARCHWARNINGSXX)
DEFAULT_INCLUDES = -isystem $$(NUTTX_EXPORT)/include
INCLUDES +=

CFLAGS += $$(TARGET_ARCH) $$(DEBUG) $$(OPTIMIZE)
CFLAGS	+= -Wall
CFLAGS += -I$$(SOURCES_DIR)
CFLAGS += -I$$(INCLUDE_DIR)

LDFLAGS := $$(filter-out -Map=%, $$(LDFLAGS))
LDFLAGS  += -L"$(NUTTX_EXPORT)/libs"

ifeq ($(word 2,$(AR)),)
ARFLAGS = rcs
else
ARFLAGS =
endif

ifeq ($$(LDNAME),)
LDNAME := $$(LDSCRIPT)
endif

LD_SCRIPT ?= $$(NUTTX_EXPORT)/scripts/$$(LDNAME)

ifneq ($$(filter-out clean distclean, $$(MAKECMDGOALS)),)
ifeq ($(LDNAME),)
$$(error no LDNAME or LDSCRIPT is defined)
endif

ifeq ($$(wildcard $$(LD_SCRIPT)),)
$$(error LD_SCRIPT='$$(LD_SCRIPT)' does not exists, correct config.target)
endif
endif

LD_SCRIPT = $$(NUTTX_EXPORT)/scripts/$$(LDNAME)

ELF_FILE_LDSCRIPT?=$$(wildcard $$(NUTTX_EXPORT)/scripts/gnu-elf.ld)

LOADLIBES += -L$$(LIB_DIR)
LOADLIBES += $$(lib_LOADLIBES:%=-l%)

-include $$(OBJS_DIR)/*.d

SOURCES2OBJS = $$(OBJ_EXT)/.c $$(OBJ_EXT)/.cc $$(OBJ_EXT)/.cxx $$(OBJ_EXT)/.S $$(OBJ_EXT)/.s $$(OBJ_EXT)/$$(OBJ_EXT)

SOURCES2OBJSLO = .lo/.c .lo/.cc .lo/.cxx .lo/.S .lo/.s .lo/.lo

#%.lo: %.c
#	$(CC) -o $@ $(LCFLAGS) -c $<

c_o_COMPILE = $$(CC) $$(DEFS) $$(DEFAULT_INCLUDES) $$(INCLUDES) $$(OMK_CPPFLAGS) \
	$$(CPPFLAGS) $$(OMK_CFLAGS) $$(CFLAGS)

cc_o_COMPILE = $$(CXX) $$(DEFS) $$(DEFAULT_INCLUDES) $$(INCLUDES) $$(OMK_CPPFLAGS) \
	$$(CPPFLAGS) $$(CXXFLAGS) $$(OMK_CFLAGS) $$(CFLAGS)

S_o_COMPILE = $$(CC) $(DEFS) $(DEFAULT_INCLUDES) $$(INCLUDES) \
	$$(CPPFLAGS) $$(OMK_CFLAGS) $$(CFLAGS) $$(ASFLAGS)


# Check GCC version for user build
ifndef CC_MAJOR_VERSION
CC_MAJOR_VERSION = $$(shell $$(CC) -dumpversion | $(SED4OMK) -e 's/\([^.]\)\..*/\1/')
endif
# Prepare suitable define for dependency building
ifeq ($$(CC_MAJOR_VERSION),2)
CC_DEPFLAGS = -Wp,-MD,"$$@.d.tmp"
else
CC_DEPFLAGS = -MT $$@ -MD -MP -MF "$$@.d.tmp"
endif

endef # COMPILER_DEFS_template


# Syntax: $(call COMPILE_c_o_template,<source>,<target>,<additional c-flags>)
define COMPILE_c_o_template
$(2): $(1) $$(GEN_HEADERS)
	@$(QUIET_CMD_ECHO) "  CC      $$@"
	$(Q) if $$(c_o_COMPILE) $$(CC_DEPFLAGS) $(3) -o $$@ -c $$< ; \
	then mv -f "$$@.d.tmp" "$$@.d" ; \
	else rm -f "$$@.d.tmp" ; exit 1; \
	fi
endef


# Syntax: $(call COMPILE_cc_o_template,<source>,<target>,<additional c-flags>)
define COMPILE_cc_o_template
$(2): $(1) $$(GEN_HEADERS)
	@$(QUIET_CMD_ECHO) "  CXX     $$@"
	$(Q) if $$(cc_o_COMPILE) $$(CC_DEPFLAGS) $(3) -o $$@ -c $$< ; \
	then mv -f "$$@.d.tmp" "$$@.d" ; \
	else rm -f "$$@.d.tmp" ; exit 1; \
	fi
endef

# Syntax: $(call COMPILE_S_o_template,<source>,<target>,<additional c-flags>)
define COMPILE_S_o_template
$(2): $(1) $$(GEN_HEADERS)
	@$(QUIET_CMD_ECHO) "  AS      $$@"
	$(Q) if $$(S_o_COMPILE) -D__ASSEMBLY__ $$(CC_DEPFLAGS) $(3) -o $$@ -c $$< ; \
	then if [ -e "$$@.d.tmp" ] ; then mv -f "$$@.d.tmp" "$$@.d" ; fi ; \
	else rm -f "$$@.d.tmp" ; exit 1; \
	fi
endef

# Syntax: $(call PROGRAM_template,<executable-name>,<dir>,<link-variant>)
define PROGRAM_template

GEN_SOURCES += $$($(1)_GEN_SOURCES)

$(foreach x, $(SOURCES2OBJS),
$(1)_OBJS += $$(patsubst %$(notdir $(x)),%$(dir $(x)),$$(filter %$(notdir $(x)),\
		$$($(1)_SOURCES) $$($(1)_GEN_SOURCES)))
)
$(1)_OBJS += $$($(1)_EMBEDROMFS:%=%_img$$(OBJ_EXT))
$(1)_OBJS := $$(sort $$($(1)_OBJS:%/=%))

SOURCES += $$($(1)_SOURCES)
EMBEDROMFS += $$($(1)_EMBEDROMFS)

ifneq ($$($(1)_PROGBUILTIN),)
ifneq ($$($(1)_PROGBUILTIN),all)
$(1)_PROGBUILTIN_TMP = $$($(1)_PROGBUILTIN)
else
$(1)_PROGBUILTIN_TMP1 = $$(wildcard $$(USER_REGISTRY_DIR)/*.pbi)
$(1)_PROGBUILTIN_TMP = $$($(1)_PROGBUILTIN_TMP1:$$(USER_REGISTRY_DIR)/%.pbi=%)
endif
$(1)_PROGBUILTIN_LIST = $$(filter-out $$($(1)_PROGBUILTIN_EXCLUDE),$$($(1)_PROGBUILTIN_TMP))

$(1)_PROGBUILTIN_OTHER=$$(filter-out $(1),$$($(1)_PROGBUILTIN_LIST))
$(1)_PROGBUILTIN_PBI=$$($(1)_PROGBUILTIN_OTHER:%=$$(USER_REGISTRY_DIR)/%.pbi)
$(1)_PROGBUILTIN_LDAT=$$($(1)_PROGBUILTIN_LIST:%=$$(USER_REGISTRY_DIR)/%.ldat)
$(1)_PROGBUILTIN_PDAT=$$($(1)_PROGBUILTIN_LIST:%=$$(USER_REGISTRY_DIR)/%.pdat) \
	$$(filter-out $$($(1)_PROGBUILTIN_EXCLUDE:%=$(NUTTXREGISTRY)/%.pdat),\
	$$(wildcard $(NUTTXREGISTRY)/*.pdat))
$(1)_PROGBUILTIN_BDAT=$$($(1)_PROGBUILTIN_LIST:%=$$(USER_REGISTRY_DIR)/%.bdat) \
	$$(filter-out $$($(1)_PROGBUILTIN_EXCLUDE:%=$(NUTTXREGISTRY)/%.bdat),\
	$$(wildcard $(NUTTXREGISTRY)/*.bdat))

ifneq ($$($(1)_KMODBUILTIN),all)
$(1)_KMODBUILTIN_LIBS = $$($(1)_KMODBUILTIN:%=$$(KERN_MODULES_DIR)/lib%.ka)
else
$(1)_KMODBUILTIN_LIBS = $$(wildcard $$(KERN_MODULES_DIR)/lib*.ka)
endif


ifneq ($$($(1)_PROGBUILTIN_PDAT),)
$(1)_BUILTINTABLE = $(OBJS_DIR)/$(1)-builtintab.c

$$($(1)_BUILTINTABLE): $$($(1)_PROGBUILTIN_PDAT) $$($(1)_PROGBUILTIN_BDAT)
	$(Q) cat $$($(1)_PROGBUILTIN_PDAT) >$$@
	$(Q) echo "#include <nuttx/config.h>" >>$$@
	$(Q) echo "#include <nuttx/lib/builtin.h>" >>$$@
	$(Q) echo "const struct builtin_s g_builtins[] = {" >>$$@
	$(Q) cat $$($(1)_PROGBUILTIN_BDAT) >>$$@
	$(Q) echo "{ NULL, 0, 0, 0 }};" >>$$@
	$(Q) echo "const int g_builtin_count = sizeof(g_builtins) / sizeof(g_builtins[0]);" >>$$@

GEN_SOURCES += $$($(1)_BUILTINTABLE)

$(1)_BUILTINWRAPMAIN = $(OBJS_DIR)/$(1)-builtinwrapmain.c

$$($(1)_BUILTINWRAPMAIN):
	$(Q) echo "#include <nuttx/config.h>" >$$@
	$(Q) echo "#include <nuttx/compiler.h>" >>$$@
	$(Q) echo "int main(int argc, FAR char *argv[]);" >>$$@
	$(Q) echo "int weak_function $(1)_main(int argc, FAR char *argv[]) {return main(argc, argv);}" >>$$@

GEN_SOURCES += $$($(1)_BUILTINWRAPMAIN)

endif
endif

ifneq ($$(LD_SCRIPT$(3:%=-%)),)
$(1)$(3:%=-%)_LD_SCRIPT_FN = $$(LD_SCRIPT$(3:%=-%))
else
$(1)$(3:%=-%)_LD_SCRIPT_FN = $$(LD_SCRIPT)
endif

ifeq ($$(dir $$($(1)$(3:%=-%)_LD_SCRIPT_FN)),)
$(1)$(3:%=-%)_LD_SCRIPT = $$(LIB_DIR)/$$($(1)$(3:%=-%)_LD_SCRIPT_FN)
else
$(1)$(3:%=-%)_LD_SCRIPT = $$($(1)$(3:%=-%)_LD_SCRIPT_FN)
endif

$(1)$(3:%=-%)_LDFLAGS = $$(CC_LD_OPTION)-T$$(LD_OPTION_SEP)$$($(1)$(3:%=-%)_LD_SCRIPT)

$(2)/$(1)$(3:%=-%): $$($(1)_OBJS) $$($(1)_BUILTINTABLE:%.c=%$$(OBJ_EXT)) $$($(1)_BUILTINWRAPMAIN:%.c=%$$(OBJ_EXT)) $$($(1)_PROGBUILTIN_LDAT) $$($(1)$(3:%=-%)_LD_SCRIPT) $$($(1)_KMODBUILTIN_LIBS)
	@$(QUIET_CMD_ECHO) "  LINK    $$@"
	$(Q) $$(if $$(LD_BY_CC) , $$(if $$(filter %.cc,$$($(1)_SOURCES)) , \
	    $$(CXX) $$(CPPFLAGS) $$(OMK_CPPFLAGS) $$(OMK_CXXFLAGS) $$(CXXFLAGS) , \
	    $$(CC)  $$(CPPFLAGS) $$(OMK_CPPFLAGS) $$(OMK_CFLAGS)   $$(CFLAGS) ) , \
	    $$(LD) \
	  ) \
	  $$(OMK_LDFLAGS) $$(LDFLAGS) $$($(1)$(3:%=-%)_LDFLAGS) $$(CC_LD_OPTION)-Map$$(LD_OPTION_SEP)$(1)$(3:%=-%).map \
	  $$($(1)_OBJS) $$($(1)_MOREOBJS) $$($(1)_BUILTINTABLE:%.c=%$$(OBJ_EXT)) $$($(1)_BUILTINWRAPMAIN:%.c=%$$(OBJ_EXT)) \
	  $$($(1)_PROGBUILTIN_PBI) $$(LOADLIBES) $$($(1)_LIBS:%=-l%) $$($(1)_KMODBUILTIN_LIBS) \
	  $$(shell for i in $$($(1)_PROGBUILTIN_LDAT); do cat $$$$i ; done) $$(NUTTXLIBES) \
	  -o $$@
	@echo "$(2)/$(1)$(3:%=-%): \\" >$(OBJS_DIR)/$(1)$(3:%=-%).exe.d
	@$(SED4OMK) -n -e 's|^LOAD \(.*\)$$$$|  \1  \&|p' $(OBJS_DIR)/$(1)$(3:%=-%).map|tr '&' '\134'  >>$(OBJS_DIR)/$(1)$(3:%=-%).exe.d
	@echo >>$(OBJS_DIR)/$(1).exe.d
endef

# Syntax: $(call ELF_template,<executable-name>,<dir>)
define ELF_template

$(2)/$(1).elf: $$($(1)_OBJS)
	@$(QUIET_CMD_ECHO) "  ELF     $$@"
	$(Q) $(LD_RAW) \
	  -r -e main -T $(ELF_FILE_LDSCRIPT) \
	  -Map $(1).elf.map \
	  $$($(1)_OBJS) $$($(1)_MOREOBJS) $$(LOADLIBES) $$($(1)_LIBS:%=-l%) \
	  -o $$@
	@echo "$(2)/$(1).elf: \\" >$(OBJS_DIR)/$(1).elf.d
	@echo "  $(ELF_FILE_LDSCRIPT) \\" >>$(OBJS_DIR)/$(1).elf.d
	@$(SED4OMK) -n -e 's|^LOAD \(.*\)$$$$|  \1  \&|p' $(OBJS_DIR)/$(1).elf.map|tr '&' '\134'  >>$(OBJS_DIR)/$(1).elf.d
	@echo >>$(OBJS_DIR)/$(1).elf.d
endef

# Syntax: $(call PROGBUILTIN_template,<executable-name>,<dir>,<registry-dir>)
define PROGBUILTIN_template

$(1)_PRIORITY ?= SCHED_PRIORITY_DEFAULT
$(1)_STACKSIZE ?= 2048

$(2)/$(1).pbi: $$($(1)_OBJS)
	@$(QUIET_CMD_ECHO) "  PROGMOD $$@"
	$(Q) $(LD_RAW) \
	  -r -x --defsym=$(1)_main=main \
	  -Map $(1).pbi.map \
	  $$($(1)_OBJS) $$($(1)_MOREOBJS) \
	  -o $(OBJS_DIR)/$(1).pbo
	$(Q) $(OBJCOPY) --keep-global-symbol=$(1)_main $(OBJS_DIR)/$(1).pbo $$@
	@echo "$(2)/$(1).pbi: \\" >$(OBJS_DIR)/$(1).pbi.d
	@$(SED4OMK) -n -e 's|^LOAD \(.*\)$$$$|  \1  \&|p' $(OBJS_DIR)/$(1).pbi.map|tr '&' '\134'  >>$(OBJS_DIR)/$(1).pbi.d
	@echo >>$(OBJS_DIR)/$(1).pbi.d
	@echo "{ \"$1\", $$($(1)_PRIORITY), $$($(1)_STACKSIZE), $(1)_main }," >$(3)/$(1).bdat
	@echo "int $(1)_main(int argc, char *argv[]);" >$(3)/$(1).pdat
	@echo "$$(LOADLIBES) $$($(1)_LIBS:%=-l%)" >$(3)/$(1).ldat
endef


# Rules for other output formats (can be specified by OUTPUT_FORMATS)
%.bin: %
	@$(QUIET_CMD_ECHO) "  OBJCOPY $@"
	$(Q) $(OBJCOPY)  --output-target=binary -S $< $@

%.hex: %
	@$(QUIET_CMD_ECHO) "  OBJCOPY $@"
	$(Q) $(OBJCOPY)  --output-target=ihex -S $< $@

%.srec: %
	@$(QUIET_CMD_ECHO) "  OBJCOPY $@"
	$(Q) $(OBJCOPY)  --output-target=srec -S $< $@

# Syntax: $(call LIBRARY_template,<library-name>)
define LIBRARY_template

GEN_SOURCES += $$($(1)_GEN_SOURCES)

$(foreach x, $(SOURCES2OBJS),
$(1)_OBJS += $$(patsubst %$(notdir $(x)),%$(dir $(x)),$$(filter %$(notdir $(x)),\
		$$($(1)_SOURCES) $$($(1)_GEN_SOURCES)))
)
$(1)_OBJS += $$($(1)_EMBEDROMFS:%=%_img$$(OBJ_EXT))
$(1)_OBJS := $$(sort $$($(1)_OBJS:%/=%))

SOURCES += $$($(1)_SOURCES)
EMBEDROMFS += $$($(1)_EMBEDROMFS)

$(LIB_DIR)/lib$(1)$$(LIB_EXT): $$($(1)_OBJS)
	@$(QUIET_CMD_ECHO) "  AR      $$@"
	$(Q) $(AR) $(ARFLAGS) $$@ $$^
endef


# Syntax: $(call SOLIB_template,<library-name>)
define SOLIB_template

SOLIB_GEN_SOURCES += $$($(1)_GEN_SOURCES)

$(foreach x, $(SOURCES2OBJSLO),
$(1)_OBJSLO += $$(patsubst %$(notdir $(x)),%$(dir $(x)),$$(filter %$(notdir $(x)),\
		$$($(1)_SOURCES) $$($(1)_GEN_SOURCES)))
)
$(1)_OBJSLO := $$(sort $$($(1)_OBJSLO:%/=%))

SOLIB_OBJS  += $$($(1)_OBJSLO)
SOLIB_SOURCES += $$($(1)_SOURCES)

$(LIB_DIR)/lib$(1).so: $$($(1)_OBJSLO)
	@$(QUIET_CMD_ECHO) "  LINK    $$@"
	$(Q) $(LD_RAW) --shared --soname=lib$(1).so -o $$@ $$^
endef

ifneq ($(bin_PROGRAMS),)
library-pass_HOOKS += force_builtin_library_hook

.PHONY: force_builtin_library_hook
force_builtin_library_hook:

endif

# Syntax: $(call ROMFS_template,<filename>,<filename2>,<directory>) FIXME: Is this correct?
define ROMFS_template

.PHONY: $(2)

$(2):
	$(Q) genromfs -f $(2).tmp -V $(1) -d $(3)
	$(Q) if ( [ ! -e $(2) ] || ! cmp -s $(2).tmp $(2) ) ; then cp $(2).tmp $(2) ; fi

$(2)$$(OBJ_EXT): $(2)
	@$(QUIET_CMD_ECHO) "  ROMFS   $$@"
	$(Q) $(LD_RAW) -r --accept-unknown-input-arch -b binary \
		--defsym=$(2)_size=_binary_$(2)_size \
		--defsym=$(2)_start=_binary_$(2)_start \
		--defsym=$(2)_end=_binary_$(2)_end \
		-o $$@.tmp $$^
	$(Q) $(OBJCOPY) --rename-section .data=.rodata,alloc,load,readonly,data,contents \
		$$@.tmp $$@

endef
KERN_MQ=\"                                                                       #OMK:nuttx-kernel.omk@Makefile.rules.nuttx
KERN_AR = $(AR)
KERN_OBJCOPY = $(OBJCOPY)
KERN_SOURCES2OBJS = .ko/.c .ko/.cc .ko/.cxx .ko/.S .ko/.s .ko/.ko

c_o_kern_COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(OMK_CPPFLAGS) \
	$(CPPFLAGS) $(OMK_CFLAGS) $(CFLAGS)

cc_o_kern_COMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(OMK_CPPFLAGS) \
	$(CPPFLAGS) $(CXXFLAGS) $(OMK_CFLAGS) $(CFLAGS)

S_o_kern_COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
	$(CPPFLAGS) $(OMK_CFLAGS) $(CFLAGS) $(ASFLAGS)

kern_CC_DEPFLAGS = $(CC_DEPFLAGS)

define COMPILE_c_o_kern_template

$(2): $(1)
	@$(QUIET_CMD_ECHO) "  CC [K]  $$@"
	$(Q) if $$(c_o_kern_COMPILE) $$(kern_CC_DEPFLAGS) $(3) $(KERN_KBUILD_MODNAME) \
	-D"KBUILD_BASENAME=$(KERN_MQ)$(notdir $(basename $(1)))$(KERN_MQ)" \
	-o $$@ -c $$< ; \
	then mv -f "$$@.d.tmp" "$$@.d" ; \
	else rm -f "$$@.d.tmp" ; exit 1; \
	fi
endef



define COMPILE_cc_o_kern_template

$(2): $(1)
	@$(QUIET_CMD_ECHO) "  CXX [K] $$@"
	$(Q) if $$(cc_o_kern_COMPILE) $$(kern_CC_DEPFLAGS) $(3) $(KERN_KBUILD_MODNAME) \
	-D"KBUILD_BASENAME=$(KERN_MQ)$(notdir $(basename $(1)))$(KERN_MQ)" \
	-o $$@ -c $$< ; \
	then mv -f "$$@.d.tmp" "$$@.d" ; \
	else rm -f "$$@.d.tmp" ; exit 1; \
	fi
endef



define COMPILE_S_o_kern_template

$(2): $(1)
	@$(QUIET_CMD_ECHO) "  AS [K]  $$@"
	$(Q) if $$(S_o_kern_COMPILE) $$(kern_CC_DEPFLAGS) $(3) $(KERN_KBUILD_MODNAME) \
	-D"KBUILD_BASENAME=$(KERN_MQ)$(notdir $(basename $(1)))$(KERN_MQ)" \
	-o $$@ -c $$< ; \
	then mv -f "$$@.d.tmp" "$$@.d" ; \
	else rm -f "$$@.d.tmp" ; exit 1; \
	fi
endef



# Syntax: $(call MODULE_kern_template,<module-name>,<dir>
define MODULE_kern_template
$(foreach x, $(KERN_SOURCES2OBJS),
$(1)_OBJS += $$(patsubst %$(notdir $(x)),%$(dir $(x)),$$(filter %$(notdir $(x)),\
		$$($(1)_SOURCES) $$($(1)_GEN_SOURCES)))
)
$(1)_OBJS := $$(sort $$($(1)_OBJS:%/=%))

KERN_OBJS  += $$($(1)_OBJS)
KERN_SOURCES += $$($(1)_SOURCES)

$(2)/$(1)$(KERN_LINK_SUFFIX): $$($(1)_OBJS)
	@$(QUIET_CMD_ECHO) "  LD [K]  $$@"
	$(Q) $(LD_RAW) \
	  -r -e module_initialize -T $(ELF_FILE_LDSCRIPT) \
	  -Map $(1)$(KERN_LINK_SUFFIX).map \
	  $$($(1)_OBJS) $$($(1)_MOREOBJS) $$(LOADLIBES) $$($(1)_LIBS:%=-l%) \
	  -o $$@
	@echo "$(2)/$(1)$(KERN_LINK_SUFFIX): \\" >$(OBJS_DIR)/$(1)$(KERN_LINK_SUFFIX).d
	@echo "  $(ELF_FILE_LDSCRIPT) \\" >>$(OBJS_DIR)/$(1)$(KERN_LINK_SUFFIX).d
	@$(SED4OMK) -n -e 's|^LOAD \(.*\)$$$$|  \1  \&|p' $(OBJS_DIR)/$(1)$(KERN_LINK_SUFFIX).map|tr '&' '\134'  >>$(OBJS_DIR)/$(1)$(KERN_LINK_SUFFIX).d
	@echo >>$(OBJS_DIR)/$(1)$(KERN_LINK_SUFFIX).d

$(2)/lib$(1).ka: $$($(1)_OBJS)
	@$(QUIET_CMD_ECHO) "  AR [K]  $$@"
	$(Q) $(KERN_AR) rcs $(1).ka.tmp $$^
	$(Q) $(KERN_OBJCOPY) --redefine-sym module_initialize=$(1)_module_initialize $(1).ka.tmp $$@

endef

define LIBRARY_kern_template
$(foreach x, $(KERN_SOURCES2OBJS),
$(1)_OBJS += $$(patsubst %$(notdir $(x)),%$(dir $(x)),$$(filter %$(notdir $(x)),\
		$$($(1)_SOURCES) $$($(1)_GEN_SOURCES)))
)
$(1)_OBJS := $$(sort $$($(1)_OBJS:%/=%))

KERN_OBJS  += $$($(1)_OBJS)
KERN_SOURCES += $$($(1)_SOURCES)

$(KERN_LIB_DIR)/lib$(1).ka: $$($(1)_OBJS)
	@$(QUIET_CMD_ECHO) "  AR [K]  $$@"
	$(Q) $(KERN_AR) rcs $$@ $$^
endef

ifneq ($(kernel_MODULES),)
binary-pass_REQUIRED=y
endif

ifneq ($(kernel_LIBRARIES),)
library-pass_REQUIRED=y
endif
ifeq ($(OMK_VERBOSE),1)                                                          #OMK:include.omk@Makefile.rules.nuttx
CPHEADER_FLAGS += -v
LNHEADER_FLAGS += -v
endif

ifneq ($(LN_HEADERS),y)
define cp_cmd
if ! cmp -s $(1) $(2); then \
    echo "  CP      $(1:$(OUTPUT_DIR)/%=%) -> $(2:$(OUTPUT_DIR)/%=%)"; \
    install -d $(CPHEADER_FLAGS) `dirname $(2)` && \
    install $(CPHEADER_FLAGS) $(1) $(2) || exit 1; \
fi
endef
else
define cp_cmd
if ! cmp -s $(1) $(2); then \
    echo "  LN      $(1:$(OUTPUT_DIR)/%=%) -> $(2:$(OUTPUT_DIR)/%=%)"; \
    if [ -f $(1) ]; then d=$(2); mkdir -p $${d%/*} && ln -sf $(LNHEADER_FLAGS) $(1) $(2) || exit 1; else exit 1; fi; \
fi
endef
endif

# TODO: Check modification date of changed header files. If it is
# newer that in source dir, show a warning.

# Syntax: $(call include-pass-template,<include dir>,<keyword>)
define include-pass-template
include-pass-local: include-pass-local-$(2)
include-pass-local-$(2): $$($(2)_GEN_HEADERS) $$(foreach f,$$(renamed_$(2)_GEN_HEADERS),$$(shell f='$$(f)'; echo $$$${f%->*}))
	@$$(foreach f, $$($(2)_HEADERS),$$(call cp_cmd,$$(SOURCES_DIR)/$$(f),$(1)/$$(notdir $$(f))); )
# FIXME: Use correct build dir, then document it (in the line bellow)
	@$$(foreach f, $$($(2)_GEN_HEADERS),$$(call cp_cmd,$$(LOCAL_BUILD_DIR)/$$(f),$(1)/$$(notdir $$(f))); )
	@$$(foreach f, $$(nobase_$(2)_HEADERS), $$(call cp_cmd,$$(SOURCES_DIR)/$$(f),$(1)/$$(f)); )
	@$$(foreach f, $$(renamed_$(2)_HEADERS), \
	   f='$$(f)'; srcfname=$$$${f%->*}; destfname=$$$${f#*->}; \
	   $$(call cp_cmd,$$(SOURCES_DIR)/$$$${srcfname},$(1)/$$$${destfname}); )
	@$$(foreach f, $$(renamed_$(2)_GEN_HEADERS), \
	   f='$$(f)'; srcfname=$$$${f%->*}; destfname=$$$${f#*->}; \
	   $$(call cp_cmd,$$(LOCAL_BUILD_DIR)/$$$${srcfname},$(1)/$$$${destfname}); )
# Suppress "Nothing to be done for `include-pass-local'" message if no headers are defined in Makefile.omk
	@$$(if $$($(2)_HEADERS)$$($(2)_GEN_HEADERS)$$(nobase_$(2)_HEADERS)$$(renamed_$(2)_HEADERS)$$(renamed_$(2)_GEN_HEADERS),,true)
endef
                                                                                 #OMK:sysless.omk@Makefile.rules.nuttx
BUILD_DIR_NAME = _build$(addprefix /,$(PREFIX_DIR))
COMPILED_DIR_NAME = _compiled$(addprefix /,$(PREFIX_DIR))

LOCAL_BUILD_DIR=$(MAKERULES_DIR)/$(BUILD_DIR_NAME)/$(RELATIVE_DIR)
#$(warning LOCAL_BUILD_DIR = $(LOCAL_BUILD_DIR))

#=====================================================================
# Common utility rules

link_VARIANTS ?= $(DEFAULT_LD_SCRIPT_VARIANT)


#=====================================================================
# Include correct rules for just running pass

USER_COMPILED_DIR_NAME=$(MAKERULES_DIR)/$(COMPILED_DIR_NAME)

USER_INCLUDE_DIR = $(USER_COMPILED_DIR_NAME)/include
USER_LIB_DIR     = $(USER_COMPILED_DIR_NAME)/lib
USER_UTILS_DIR   = $(USER_COMPILED_DIR_NAME)/bin-utils
USER_TESTS_DIR   = $(USER_COMPILED_DIR_NAME)/bin-tests
USER_BIN_DIR     = $(USER_COMPILED_DIR_NAME)/bin
USER_OBJS_DIR    = $(LOCAL_BUILD_DIR)

.PHONY: check-dir

# Some support to serialize some targets for parallel make
ifneq ($(OMK_SERIALIZE_INCLUDED),y)
include-pass: check-dir
library-pass: include-pass
binary-pass utils-pass: library-pass

override OMK_SERIALIZE_INCLUDED = y
MAKEOVERRIDES := $(filter-out OMK_SERIALIZE_INCLUDED=n,$(MAKEOVERRIDES))
endif

# -------------------------------------
# Rules for compilation for target
ifdef TARGET_RULE_TEMPLATES

ifeq ($(TARGET_STDSTARTFILES),)
TARGET_STDSTARTFILES=n
endif

ifneq ($(TARGET_STDSTARTFILES),y)
LDFLAGS += -nostartfiles
ifneq ($(TARGET_STDSTARTFILES),n)
LDFLAGS += $(TARGET_STDSTARTFILES)
endif
endif

# FIXME: These are not used. What they are good for?
LIB_CPPFLAGS += $(CPPFLAGS)
LIB_CFLAGS   += $(CFLAGS)

SOLIB_PICFLAGS += -shared -fpic

CFLAGS += -DOMK_FOR_TARGET

INCLUDE_DIR := $(USER_INCLUDE_DIR)
LIB_DIR     := $(USER_LIB_DIR)
OBJS_DIR    := $(USER_OBJS_DIR)

$(eval $(COMPILER_DEFS_template))

# Generate rules for compilation of programs and libraries
ifneq ($(link_VARIANTS),)
$(foreach prog,$(bin_PROGRAMS),$(foreach link,$(link_VARIANTS),$(eval $(call PROGRAM_template,$(prog),$(USER_BIN_DIR),$(link)))))
$(foreach prog,$(test_PROGRAMS),$(foreach link,$(link_VARIANTS),$(eval $(call PROGRAM_template,$(prog),$(USER_TESTS_DIR),$(link)))))
else
$(foreach prog,$(bin_PROGRAMS),$(eval $(call PROGRAM_template,$(prog),$(USER_BIN_DIR))))
$(foreach prog,$(test_PROGRAMS),$(eval $(call PROGRAM_template,$(prog),$(USER_TESTS_DIR))))
endif

$(foreach lib,$(lib_LIBRARIES),$(eval $(call LIBRARY_template,$(lib))))
$(foreach src,$(lib_obj_SOURCES),$(eval $(call LIBOBJ_template,$(addsuffix $(OBJ_EXT),$(basename $(src))))))
$(foreach lib,$(shared_LIBRARIES),$(eval $(call SOLIB_template,$(lib))))


# lib_obj_SOURCES handling
lib_OBJS = $(addsuffix $(OBJ_EXT),$(basename $(lib_obj_SOURCES)))
#$(warning lib_OBJS = $(lib_OBJS))
SOURCES += $(filter-out %$(OBJ_EXT),$(lib_obj_SOURCES))

$(LIB_DIR)/%$(OBJ_EXT): %$(OBJ_EXT)
	@echo "  CP      $(^:$(MAKERULES_DIR)/%=%) -> $(@:$(MAKERULES_DIR)/%=%)"
	$(Q)cp $(CP_FLAGS) $< $@


# User-space static libraries and applications object files
SOURCES := $(sort $(SOURCES))
#$(warning SOURCES = $(SOURCES))
GEN_SOURCES := $(sort $(GEN_SOURCES))

# User-space shared libraries object files
SOLIB_SOURCES := $(sort $(SOLIB_SOURCES))
#$(warning SOLIB_SOURCES = $(SOLIB_SOURCES))
SOLIB_GEN_SOURCES := $(sort $(SOLIB_GEN_SOURCES))

# Create _build directories for sources in subdirectories i.e. *_SOURCES=dir/file.c
_dirs_to_create=$(filter-out ./,$(sort $(dir $(SOURCES) $(SOLIB_SOURCES))))
ifneq ($(_dirs_to_create),)
$(shell mkdir -p $(addprefix $(LOCAL_BUILD_DIR)/,$(_dirs_to_create)))
endif

# The above generated rules produced $(SOURCES) and $(SOLIB_SOURCES)
# variables. Now generate rules for compilation of theese sources
$(foreach src,$(filter %.c,$(SOURCES)),$(eval $(call COMPILE_c_o_template,$(SOURCES_DIR)/$(src),$(src:%.c=%$(OBJ_EXT)),)))
$(foreach src,$(filter %.cc,$(SOURCES)),$(eval $(call COMPILE_cc_o_template,$(SOURCES_DIR)/$(src),$(src:%.cc=%$(OBJ_EXT)),)))
$(foreach src,$(filter %.cxx,$(SOURCES)),$(eval $(call COMPILE_cc_o_template,$(SOURCES_DIR)/$(src),$(src:%.cxx=%$(OBJ_EXT)),)))
$(foreach src,$(filter %$(ASM_EXT),$(SOURCES)),$(eval $(call COMPILE_S_o_template,$(SOURCES_DIR)/$(src),$(src:%$(ASM_EXT)=%$(OBJ_EXT)),)))
$(foreach src,$(filter %.s,$(SOURCES)),$(eval $(call COMPILE_S_o_template,$(SOURCES_DIR)/$(src),$(src:%.s=%$(OBJ_EXT)),)))
$(foreach src,$(filter %.c,$(GEN_SOURCES)),$(eval $(call COMPILE_c_o_template,$(src),$(src:%.c=%$(OBJ_EXT)),)))

$(foreach src,$(filter %.c,$(SOLIB_SOURCES)),$(eval $(call COMPILE_c_o_template,$(SOURCES_DIR)/$(src),$(src:%.c=%.lo),$(SOLIB_PICFLAGS))))
$(foreach src,$(filter %.cc,$(SOLIB_SOURCES)),$(eval $(call COMPILE_cc_o_template,$(SOURCES_DIR)/$(src),$(src:%.cc=%.lo),$(SOLIB_PICFLAGS))))
$(foreach src,$(filter %.cxx,$(SOLIB_SOURCES)),$(eval $(call COMPILE_cc_o_template,$(SOURCES_DIR)/$(src),$(src:%.cxx=%.lo),$(SOLIB_PICFLAGS))))
$(foreach src,$(filter %$(ASM_EXT),$(SOLIB_SOURCES)),$(eval $(call COMPILE_S_o_template,$(SOURCES_DIR)/$(src),$(src:%$(ASM_EXT)=%.lo),$(SOLIB_PICFLAGS))))
$(foreach src,$(filter %.c,$(SOLIB_GEN_SOURCES)),$(eval $(call COMPILE_c_o_template,$(src),$(src:%.c=%.lo),$(SOLIB_PICFLAGS))))

library-pass-local: $(lib_LIBRARIES:%=$(LIB_DIR)/$(LIB_PREF)%$(LIB_EXT)) $(shared_LIBRARIES:%=$(LIB_DIR)/$(LIB_PREF)%.so) \
		    $(addprefix $(LIB_DIR)/,$(lib_OBJS))

ifneq ($(link_VARIANTS),)
binary-pass-local:  $(foreach link,$(link_VARIANTS),$(bin_PROGRAMS:%=$(USER_BIN_DIR)/%-$(link)) $(test_PROGRAMS:%=$(USER_TESTS_DIR)/%-$(link)) \
		    $(foreach of,$(OUTPUT_FORMATS),$(bin_PROGRAMS:%=$(USER_BIN_DIR)/%-$(link).$(of)) $(test_PROGRAMS:%=$(USER_TESTS_DIR)/%-$(link).$(of))))
else
binary-pass-local:  $(bin_PROGRAMS:%=$(USER_BIN_DIR)/%) $(test_PROGRAMS:%=$(USER_TESTS_DIR)/%) \
		    $(foreach of,$(OUTPUT_FORMATS),$(bin_PROGRAMS:%=$(USER_BIN_DIR)/%.$(of)) $(test_PROGRAMS:%=$(USER_TESTS_DIR)/%.$(of)))
endif

endif # TARGET_RULE_TEMPLATES


# -------------------------------------
# Rules for compilation utilities for host (user space)
ifdef HOST_RULE_TEMPLATES

CROSS_COMPILE =
TARGET_ARCH =

SOLIB_PICFLAGS += -shared -fpic

# For host compilation, we don't use a specfic ld script
LD_SCRIPT =

# TODO: It is probably better to use different directories for host
# includes, libraries and objects
INCLUDE_DIR := $(USER_INCLUDE_DIR)
LIB_DIR     := $(USER_LIB_DIR)
OBJS_DIR    := $(USER_OBJS_DIR)

$(eval $(COMPILER_DEFS_template))

 #User-space static libraries and applications object files
#SOURCES := $(sort $(SOURCES))
#$(warning SOURCES = $(SOURCES))

# Generate rules for compilation of utility programs
$(foreach prog,$(utils_PROGRAMS),$(eval $(call PROGRAM_template,$(prog),$(USER_UTILS_DIR),)))

# The above generated rule produced $(SOURCES) variable. Now generate
# rules for compilation of theese sources
$(foreach src,$(filter %.c,$(SOURCES)),$(eval $(call COMPILE_c_o_template,$(SOURCES_DIR)/$(src),$(src:%.c=%$(OBJ_EXT)),)))
$(foreach src,$(filter %.cc,$(SOURCES)),$(eval $(call COMPILE_cc_o_template,$(SOURCES_DIR)/$(src),$(src:%.cc=%$(OBJ_EXT)),)))
$(foreach src,$(filter %.cxx,$(SOURCES)),$(eval $(call COMPILE_cc_o_template,$(SOURCES_DIR)/$(src),$(src:%.cxx=%$(OBJ_EXT)),)))
$(foreach src,$(filter %$(ASM_EXT),$(SOURCES)),$(eval $(call COMPILE_S_o_template,$(SOURCES_DIR)/$(src),$(src:%$(ASM_EXT)=%$(OBJ_EXT)),)))

utils-pass-local: $(utils_PROGRAMS:%=$(USER_UTILS_DIR)/%)

endif # HOST_RULE_TEMPLATES

#=====================================================================
# Automatic loading of compiled program by issuing "make load"

ifneq ($(OUTPUT_FORMATS),)
# Select a file extension (e.g. .bin) for "make load" command to load.
LOAD_EXTENSION = .$(firstword $(OUTPUT_FORMATS))
endif

# Syntax: $(call LOAD_PROGRAM_template,<executable-name>,<dir>,<link-variant>)
# Used to load program to the target hardware
define LOAD_PROGRAM_template
.PHONY: load-$(1)$(3:%=-%)
load-$(1)$(3:%=-%): $(2)/$(1)$(3:%=-%)$(if $(LOAD_EXTENSION-$(3)),$(LOAD_EXTENSION-$(3)),$(LOAD_EXTENSION))
	@$(QUIET_CMD_ECHO) "  LOAD    $$<"
	@if [ -z '$$(LOAD_CMD$(3:%=-%))' ]; then echo "No command for loading applications to '$(3)' is specified."; exit 1; fi
	$(Q) $$(LOAD_CMD$(3:%=-%)) $$<
endef

# Syntax: $(call LOAD__RUN_VARIANT_template,<link-variant>)
# Used to load and/or run non-default variant of the default program
define LOAD_RUN_VARIANT_template
.PHONY: load-$(1) run-$(1)

load-$(1): load-$(firstword $(bin_PROGRAMS) $(test_PROGRAMS))-$(1)

run-$(1):
	@$(QUIET_CMD_ECHO) "  RUN     $(1)"
	@if [ -z "$(RUN_CMD-$(1))" ]; then echo "No command for running '$(1)' variant is specified."; exit 1; fi
	$(Q) $(RUN_CMD-$(1))

endef

$(foreach link,$(link_VARIANTS),$(foreach prog,$(bin_PROGRAMS),$(eval $(call LOAD_PROGRAM_template,$(prog),$(USER_BIN_DIR),$(link)))))
$(foreach link,$(link_VARIANTS),$(foreach prog,$(test_PROGRAMS),$(eval $(call LOAD_PROGRAM_template,$(prog),$(USER_TESTS_DIR),$(link)))))
$(foreach link,$(link_VARIANTS),$(eval $(call LOAD_RUN_VARIANT_template,$(link))))

.PHONY: load run
load: $(addprefix load-,$(firstword $(bin_PROGRAMS) $(test_PROGRAMS))-$(firstword $(link_VARIANTS)))

run: run-$(firstword $(link_VARIANTS))



#=====================================================================
# Generate pass rules from generic templates

$(eval $(call omk_pass_template, include-pass, $(LOCAL_BUILD_DIR),,$(include_HEADERS)$(nobase_include_HEADERS)$(renamed_include_HEADERS)$(lib_LDSCRIPTS)$(config_include_HEADERS)$(LOCAL_CONFIG_H)))
$(eval $(call omk_pass_template, library-pass, $(LOCAL_BUILD_DIR),TARGET_RULE_TEMPLATES=y,$(lib_LIBRARIES)$(shared_LIBRARIES)$(lib_obj_SOURCES)$(cmetric_include_HEADERS)))
$(eval $(call omk_pass_template, binary-pass,  $(LOCAL_BUILD_DIR),TARGET_RULE_TEMPLATES=y,$(bin_PROGRAMS) $(test_PROGRAMS)))
$(eval $(call omk_pass_template, utils-pass,   $(LOCAL_BUILD_DIR),HOST_RULE_TEMPLATES=y,$(utils_PROGRAMS)))
$(eval $(call omk_pass_template, dep,    $(LOCAL_BUILD_DIR),,always))
$(eval $(call omk_pass_template, clean,  $(LOCAL_BUILD_DIR),,always))
$(eval $(call omk_pass_template, install,$(LOCAL_BUILD_DIR),,always))


dep-local:

install-local:

$(eval $(call include-pass-template,$(USER_INCLUDE_DIR),include))

include-pass-local:
	@$(foreach f, $(lib_LDSCRIPTS), cmp --quiet $(SOURCES_DIR)/$(f) $(USER_LIB_DIR)/$(notdir $(f)) \
	   || $(call cp_cmd,$(SOURCES_DIR)/$(f),$(USER_LIB_DIR)/$(notdir $(f))) || exit 1 ; )


clean-local::
	$(Q)rm -f $(USER_OBJS_DIR)/*$(OBJ_EXT) $(USER_OBJS_DIR)/*.lo \
	       $(USER_OBJS_DIR)/*.d \
	       $(USER_OBJS_DIR)/*.map \
	       $(LOCAL_CONFIG_H:%=$(USER_OBJS_DIR)/%)

check-dir::
	@$(call mkdir_def,$(USER_INCLUDE_DIR))
	@$(call mkdir_def,$(USER_LIB_DIR))
	@$(call mkdir_def,$(USER_BIN_DIR))
	@$(call mkdir_def,$(USER_UTILS_DIR))
	@$(call mkdir_def,$(USER_TESTS_DIR))

include-pass-submakes: extra-rules-subdirs
# Which passes to pass
default: include-pass library-pass binary-pass utils-pass
                                                                                 #OMK:nuttx-bin.omk@Makefile.rules.nuttx
# Final rules for NuttX binaries build requests preparation

# Interface to other rules:

# Input variables:
# bin_PROGRAMS     .. list of the require binary programs
# utils_PROGRAMS   .. list of the development utility programs
# USER_BIN_DIR     .. directory to store final executables
# USER_TESTS_DIR   .. directory to store test executables

# Defined variables
# USER_REGISTRY_DIR .. directory where registry for builtin applications is stored

USER_REGISTRY_DIR = $(USER_COMPILED_DIR_NAME)/registry

# Use same output directories for kernel modules as for user
KERN_INCLUDE_DIR := $(USER_INCLUDE_DIR)
KERN_MODULES_DIR := $(OUTPUT_DIR)/$(COMPILED_DIR_NAME)/modules
KERN_LIB_DIR     := $(KERN_MODULES_DIR)
KERN_BUILD_DIR   := $(OUTPUT_DIR)/$(BUILD_DIR_NAME)
KERN_LINK_SUFFIX := .klm

$(eval $(call include-pass-template,$(KERN_INCLUDE_DIR),kernel))

$(foreach module,$(kernel_MODULES),$(eval $(call MODULE_kern_template,$(module),$(KERN_MODULES_DIR))))

$(foreach lib,$(kernel_LIBRARIES),$(eval $(call LIBRARY_kern_template,$(lib))))

KERN_SOURCES := $(sort $(KERN_SOURCES))

$(foreach src,$(filter %.c,$(KERN_SOURCES)),$(eval $(call COMPILE_c_o_kern_template,$(SOURCES_DIR)/$(src),$(src:%.c=%.ko),)))
$(foreach src,$(filter %.cc,$(KERN_SOURCES)),$(eval $(call COMPILE_cc_o_kern_template,$(SOURCES_DIR)/$(src),$(src:%.cc=%.ko),)))
$(foreach src,$(filter %.cxx,$(KERN_SOURCES)),$(eval $(call COMPILE_cc_o_kern_template,$(SOURCES_DIR)/$(src),$(src:%.cxx=%.ko),)))
$(foreach src,$(filter %.cpp,$(KERN_SOURCES)),$(eval $(call COMPILE_cc_o_kern_template,$(SOURCES_DIR)/$(src),$(src:%.cpp=%.ko),)))
$(foreach src,$(filter %.S,$(KERN_SOURCES)),$(eval $(call COMPILE_S_o_kern_template,$(SOURCES_DIR)/$(src),$(src:%.S=%.ko),)))

$(foreach romfs,$(EMBEDROMFS),$(eval $(call ROMFS_template,$(romfs),$(romfs)_img,$(SOURCES_DIR)/$(romfs))))

check-dir::
	@$(call mkdir_def,$(USER_REGISTRY_DIR))
	@$(call mkdir_def,$(KERN_MODULES_DIR))
	@$(call mkdir_def,$(KERN_BUILD_DIR))

$(foreach prog,$(bin_PROGRAMS),$(eval $(call ELF_template,$(prog),$(USER_BIN_DIR))))
$(foreach prog,$(test_PROGRAMS),$(eval $(call ELF_template,$(prog),$(USER_TESTS_DIR))))

ifneq ($(ELF_FILE_LDSCRIPT),)
binary-pass-local:  $(bin_PROGRAMS:%=$(USER_BIN_DIR)/%.elf) $(test_PROGRAMS:%=$(USER_TESTS_DIR)/%.elf)
binary-pass-local:  $(kernel_MODULES:%=$(KERN_MODULES_DIR)/%$(KERN_LINK_SUFFIX))
endif

binary-pass-local:  $(kernel_MODULES:%=$(KERN_MODULES_DIR)/lib%.ka)

$(foreach prog,$(bin_PROGRAMS),$(eval $(call PROGBUILTIN_template,$(prog),$(USER_REGISTRY_DIR),$(USER_REGISTRY_DIR))))

library-pass-local:  $(bin_PROGRAMS:%=$(USER_REGISTRY_DIR)/%.pbi)

library-pass-local: $(kernel_LIBRARIES:%=$(KERN_LIB_DIR)/lib%.ka)

clean-local::
	$(Q)rm -f $(bin_PROGRAMS:%=$(USER_REGISTRY_DIR)/%.*)
	$(Q)rm -f $(USER_OBJS_DIR)/*.pbo $(USER_OBJS_DIR)/*.ko $(USER_OBJS_DIR)/*.tmp
                                                                                 #OMK:cmetric.omk@Makefile.rules.nuttx
NM ?= nm

# Syntax: $(call CMETRIC_o_h_template,<object_file>,<target_header>)
define CMETRIC_o_h_template
$(2): $(1)
	@$(QUIET_CMD_ECHO) "  CMETRIC $$@"
	$(Q)if [ -n `dirname $$@` ] ; then \
	      if [ ! -e `dirname $$@` ] ; then \
	        mkdir -p `dirname $$@` ; fi ; fi
	$(Q)echo >$$@.tmp '/* Automatically generated from $$< */'
	$(Q)echo >>$$@.tmp '/* Conditionals to control compilation */'
# Bellow, the tricks with redirection are for shells without set -o pipefail
# (see http://www.mail-archive.com/dash@vger.kernel.org/msg00149.html)
	$(Q)exec 3>&1; status=`exec 4>&1 >&3; { $(NM) $$<; echo $$$$? >&4; }\
		| $(SED4OMK) -n 's/^ *0*\(0[0-9A-Fa-f]*\) *A *_cmetric2cond_\([A-Za-z_0-9]*\) */#define \2 0x\1/p' \
		| sort >>$$@.tmp` && exit $$$$status
	$(Q)echo >>$$@.tmp '/* Defines from the values defined to symbols in hexadecimal format */'
	$(Q)exec 3>&1; status=`exec 4>&1 >&3; { $(NM) $$<; echo $$$$? >&4; }\
		| $(SED4OMK) -n 's/^ *0*\(0[0-9A-Fa-f]*\) *A *_cmetric2def_\([A-Za-z_0-9]*\) */#define \2 0x\1/p' \
		| sort >>$$@.tmp` && exit $$$$status
	$(Q)echo >>$$@.tmp '/* Defines from the values defined to symbols in decimal format */'
	$(Q)exec 3>&1; status=`exec 4>&1 >&3; { $(NM) -td $$<; echo $$$$? >&4; }\
		| $(SED4OMK) -n 's/^ *0*\(0\|[1-9][0-9]*\) *A *_cmetric2defdec_\([A-Za-z_0-9]*\) */#define \2 \1/p' \
		| sort >>$$@.tmp` && exit $$$$status
	$(Q)mv $$@.tmp $$@
endef

library-pass-local: $(addprefix $(USER_INCLUDE_DIR)/,$(cmetric_include_HEADERS))

# Special rules for CMETRIC generated headers

$(foreach cmetrh,$(cmetric_include_HEADERS),$(eval $(call COMPILE_c_o_template,\
		$(SOURCES_DIR)/$($(basename $(notdir $(cmetrh)))_CMETRIC_SOURCES),\
		$($(basename $(notdir $(cmetrh)))_CMETRIC_SOURCES:%.c=%$(OBJ_EXT)),)))
$(foreach cmetrh,$(cmetric_include_HEADERS),$(eval $(call CMETRIC_o_h_template,\
		$($(basename $(notdir $(cmetrh)))_CMETRIC_SOURCES:%.c=%$(OBJ_EXT)),\
		$(addprefix $(USER_INCLUDE_DIR)/,$(cmetrh)))))

GEN_HEADERS+=$(cmetric_include_HEADERS:%=$(USER_INCLUDE_DIR)/%)
                                                                                 #OMK:config_h.omk@Makefile.rules.nuttx
# Syntax: $(call BUILD_CONFIG_H_template,<stamp_dir>,<header_file_path>,<list_of_options_to_export>,<header_barrier>)
define BUILD_CONFIG_H_template

$(addprefix $(1)/,$(notdir $(addsuffix .stamp,$(2)))) : $(CONFIG_FILES)
	@$(QUIET_CMD_ECHO) "  CONFGEN $(notdir $(2))"
	@if [ ! -d `dirname $(2).tmp` ] ; then \
		mkdir -p `dirname $(2).tmp` ; fi
	@echo "/* Automatically generated from */" > "$(2).tmp"
	@echo "/* config files: $$(^:$(OUTPUT_DIR)/%=%) */" >> "$(2).tmp"
	$(if $(DOXYGEN),@echo "/** @file */" >> "$(2).tmp")
	@echo "#ifndef $(4)" >> "$(2).tmp"
	@echo "#define $(4)" >> "$(2).tmp"
	@( $(foreach x, $(shell echo '$($(3))' | tr 'x\t ' 'x\n\n' | $(SED4OMK) -e 's/^\([^ =]*\)\(=[^ ]\+\|\)$$/\1/' ), \
		echo '$(x).$($(x))' ; ) echo ; ) | \
		$(SED4OMK) -e '/^[^.]*\.n$$$$/d' -e '/^[^.]*\.$$$$/d' -e 's/^\([^.]*\)\.[ym]$$$$/\1.1/' | \
		$(SED4OMK) -n -e 's/^\([^.]*\)\.\(.*\)$$$$/#define \1 \2/p' \
		  >> "$(2).tmp"
	@echo "#endif /*$(4)*/" >> "$(2).tmp"
	@touch "$$@"
	@if cmp -s "$(2).tmp" "$(2)" ; then rm "$(2).tmp"; \
	else mv "$(2).tmp" "$(2)" ; \
	echo "Updated configuration $(2)" ; fi

endef

ifdef LOCAL_CONFIG_H

# This must be declared after the default cflags are assigned!
# Override is used to override command line assignemnt.
override CFLAGS += -I $(USER_OBJS_DIR)
override kernel_INCLUDES += -I $(KERN_OBJS_DIR)
$(eval $(call BUILD_CONFIG_H_template,$(USER_OBJS_DIR),$(USER_OBJS_DIR)/$(LOCAL_CONFIG_H),default_CONFIG,_LOCAL_CONFIG_H) )

endif

# Special rules for configuration exported headers

#FIXME: The directory for headers should not be specified here.
$(foreach confh,$(config_include_HEADERS),$(eval $(call BUILD_CONFIG_H_template,$(USER_OBJS_DIR),$(addprefix $(USER_INCLUDE_DIR)/,$(confh)),$(basename $(notdir $(confh)))_DEFINES,\
_$(basename $(notdir $(confh)))_H \
)))

config_h_stamp_files = $(addprefix $(USER_OBJS_DIR)/,$(notdir $(addsuffix .stamp,$(config_include_HEADERS) $(LOCAL_CONFIG_H))))

# Add some hooks to standard passes
include-pass-local: $(config_h_stamp_files)

ifneq ($(KERN_CONFIG_HEADERS_REQUIRED),)

ifdef LOCAL_CONFIG_H
$(eval $(call BUILD_CONFIG_H_template,$(KERN_OBJS_DIR),$(KERN_OBJS_DIR)/$(LOCAL_CONFIG_H),default_CONFIG,_LOCAL_CONFIG_H) )
endif

$(foreach confh,$(config_include_HEADERS),$(eval $(call BUILD_CONFIG_H_template,$(KERN_OBJS_DIR),$(addprefix $(KERN_INCLUDE_DIR)/,$(confh)),$(basename $(notdir $(confh)))_DEFINES,\
_$(basename $(notdir $(confh)))_H \
)))

kern_config_h_stamp_files = $(addprefix $(KERN_OBJS_DIR)/,$(notdir $(addsuffix .stamp,$(config_include_HEADERS) $(LOCAL_CONFIG_H))))

# Add some hooks to standard passes
include-pass-local: $(kern_config_h_stamp_files)

endif

clean-local::
	@$(foreach confh,$(config_h_stamp_files) $(kern_config_h_stamp_files),\
	    if [ -e $(confh) ] ; then rm $(confh) ; fi ; \
	)
                                                                                 #OMK:sources-list.omk@Makefile.rules.nuttx
# Rules that creates the list of files which are used during
# compilation. The list reflects conditional compilation depending on
# config.omk and other variables.

SOURCES_LIST_FN=sources.txt
ifndef SOURCES_LIST
SOURCES_LIST_DIR:=$(RELATIVE_DIR)
SOURCES_LIST:=$(OUTPUT_DIR)/$(SOURCES_LIST_DIR)/$(SOURCES_LIST_FN)
SOURCES_LIST_D := $(LOCAL_BUILD_DIR)/$(SOURCES_LIST_FN).d
export SOURCES_LIST SOURCES_LIST_DIR SOURCES_LIST_D
endif

ifneq ($(filter sources-list TAGS tags cscope,$(MAKECMDGOALS)),)
NEED_SOURCES_LIST=y
endif

ifeq ($(NEED_SOURCES_LIST),y) # avoid execution of find command bellow if it is not useful
.PHONY: sources-list
sources-list: $(SOURCES_LIST)

$(SOURCES_LIST): $(CONFIG_FILES) $(shell find -name $(MAKEFILE_OMK))
	@$(call mkdir_def,$(dir $(SOURCES_LIST_D)))
	@echo -n "" > "$(SOURCES_LIST).tmp"
	@echo -n "" > "$(SOURCES_LIST_D).tmp"
	@$(MAKE) --no-print-directory sources-list-pass
	@echo "# Automatically generated list of files in '$(RELATIVE_DIR)' that are used during OMK compilation" > "$(SOURCES_LIST).tmp2"
	@cat "$(SOURCES_LIST).tmp"|sort|uniq >> "$(SOURCES_LIST).tmp2"
	@rm "$(SOURCES_LIST).tmp"
	@mv "$(SOURCES_LIST).tmp2" "$(SOURCES_LIST)"
	@echo "$(SOURCES_LIST): \\" > "$(SOURCES_LIST_D).tmp2"
	@cat "$(SOURCES_LIST_D).tmp"|grep -v "$(SOURCES_LIST_D).tmp"|sort|uniq|\
		$(SED4OMK) -e 's/$$/\\/' >> "$(SOURCES_LIST_D).tmp2"
	@rm "$(SOURCES_LIST_D).tmp"
	@mv "$(SOURCES_LIST_D).tmp2" "$(SOURCES_LIST_D)"
endif

$(eval $(call omk_pass_template,sources-list-pass,$$(LOCAL_BUILD_DIR),,always))

sources-list-pass-local:
	@$(foreach m,$(MAKEFILE_LIST),echo '  $(m)' >> "$(SOURCES_LIST_D).tmp";)
	@$(foreach h,$(include_HEADERS) $(nobase_include_HEADERS) $(kernel_HEADERS),\
	  echo "$(addsuffix /,$(RELATIVE_DIR:$(SOURCES_LIST_DIR)/%=%))$(h)" >> "$(SOURCES_LIST).tmp";)
	@$(foreach ch,$(config_include_HEADERS), \
	  echo "$(USER_INCLUDE_DIR:$(OUTPUT_DIR)/$(addsuffix /,$(SOURCES_LIST_DIR))%=%)/$(ch)" >> "$(SOURCES_LIST).tmp";)
	@$(foreach h,$(renamed_include_HEADERS),echo '$(h)'|$(SED4OMK) -e 's|\(.*\)->.*|$(addsuffix /,$(RELATIVE_DIR:$(SOURCES_LIST_DIR)/%=%))\1|' >> "$(SOURCES_LIST).tmp";)
	@$(foreach bin,$(lib_LIBRARIES) $(shared_LIBRARIES) $(bin_PROGRAMS) $(test_PROGRAMS) $(utils_PROGRAMS) \
	  $(kernel_LIBRARIES) $(rtlinux_LIBRARIES) $(kernel_MODULES),\
	  $(foreach src,$(filter-out %$(OBJ_EXT),$($(bin)_SOURCES)),echo "$(addsuffix /,$(RELATIVE_DIR:$(SOURCES_LIST_DIR)/%=%))$(src)" >> "$(SOURCES_LIST).tmp";))

############ TAGS ###########

ifeq ($(MAKECMDGOALS),TAGS)
ETAGS=etags
TAGS_CMD = $(ETAGS)
TAGS: $(SOURCES_LIST)
	@$(MAKE) --no-print-directory do-tags
endif
ifeq ($(MAKECMDGOALS),tags) 
CTAGS=ctags -N
TAGS_CMD = $(CTAGS)
tags: $(SOURCES_LIST)
	@$(MAKE) --no-print-directory do-tags
endif
export TAGS_CMD

ifeq ($(MAKECMDGOALS),do-tags)
.PHONY: do-tags
do-tags: $(shell $(SED4OMK) -e '/^\#/d' $(SOURCES_LIST))
	@$(QUIET_CMD_ECHO) "  TAGS    $(SOURCES_LIST_FN)"
	$(Q)$(TAGS_CMD) $^
endif

############ CSCOPE ###########

cscope: $(SOURCES_LIST)
	@$(QUIET_CMD_ECHO) "  CSCOPE  < $(SOURCES_LIST_FN)"
	$(Q)$(SED4OMK) -e '/^#/d' $(SOURCES_LIST) > cscope.files
	$(Q)cscope -b -icscope.files
#FIXME: see doc to -i in cscope(1)
                                                                                 #OMK:localeval.omk@Makefile.rules.nuttx
ifneq ($(local_EVALUATE),)
#$(warning $(local_EVALUATE))
$(eval $(local_EVALUATE))
endif
